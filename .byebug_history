c
exit
board_dup[[5,5]].board[[5,5]]
board_dup[[5,5]].class
board_dup[[5,5]]
c
exit
self.board[[6,5]].class
self.board[[5,5]].class
s
self[[5,5]].class
self[[5,5]]
self[5,5]
self.grid[5][5].class
self.grid[4][4].class
s
c
exit
self.grid[6][5].class
self.grid[4][4].class
self.grid[5][5].class
self[[5,5]].class
self[[5,4]].class
self[[4,4]].class
self[4,4].class
s
pos
s
c
exit
self.board[[5,5]]
self.board[[4,4]]
self.board[[5,3]]
self.board[[5,4]]
self.board[[5,5]]
s
pos
s
newpos
s
newpos
s
c
exit
c
cc
c
s
c
exit
Display.new(self.board).render
self.board[pos].color
     self.color == :white ? self.board[pos].color == :black : self.board[pos].color == :white
self.class
pos
s
newpos
s
opposing_piece_at_pos?([5,5])
opposing_piece_at_pos?(newpos)
newpos
s
all_moves
s
pos
s
newpos
s
forward_steps
s
c
exit
c
exit
pieces.map{|p| p.color}'
pieces.map{|p| p.color}
color
pieces[0].moves
pieces.map{|p| p.pos}
pieces.map{|p| p.pos)
pieces.map(pos)
king_pos
color
n
s
c
n
s
pieces
n
s
dup[[5,5]].class
dup[[5,5]]
dup[5,5]
dup.in_check?(:white)
c
exit
c
s
c
s
color
s
c
s
c
s
pos
s
j
i
s
king_pos
s
board_dup.in_check?(self.color)
board_dup[[5,5]].class
board_dup[[5,5]]
c
s
j
s
end_pos
s
self[start_pos].move_into_check?(end_pos)
s
endpos
c
s
c
exit
d.pieces.any?{|p| p.color != color && p.moves.include?(d.find
d.pieces.any?{|p| p.color != color && p.moves.include?(find_king(color))}
d.find_king(:white)
d[[4,4]].moves
d[[4,4]].class
d[[5,5]].class
d[[5,5]]
d.in_check?(:black)
d.in_check?(:white)
Display.new(d).render
d.move_piece!(self.pos, end_pos)
d = self.board.dup
Display.new(self.board.dup).render
self.board.dup.move_piece!(self.pos, end_pos)
board_dup.move_piece!(self.pos, end_pos)
Display.new(self.board.dup).render
end_pos
s
c
exit
Display.new(self.board.dup).render
s
end_pos
s
c
exit
c
s
end_pos
s
self[start_pos].move_into_check?(end_pos)
s
end_pos
s
c
 c
c
s
c
color
c
s
valid_moves
s
end_pos
c
opposing_pieces.any?{|piece| piece.moves.include?(king_pos)}
c
s
c
exit
self.board[[5,3]].class
self.board[[3,4]].class
self.board[[3,3]].class
self.board[[4,3]]
pos
self.board[pos]
Display.new(self.board).render
pos
s
Display.new(self.board).render
pos
s
Display.new(self.board).render
self.board
self.board([5,3])
self.board[5,3]
self.board[self.pos]
self.board[pos]
self.color == :white ? self.board[pos].color == :black : self.board[pos].color == :white
pos
s
newpos
s
c
newpos
newps
s
c
Display.new(self.board).render
pos
self.board[pos]
self.board[pos].color
self.pos
self.color == :white ? self.board[pos].color == :black : self.board[pos].color == :white
pos[0].between?(0, 7)
pos
self.color
pos
c
cc
c
cc
c
cc
c
cc
c
finish
c
pos
c
pos
po
c
pos
c
opposing_piece_at_pos?(newpos)
newpos
s
opposing_pieces.first.moves
Display.new(self).render
opposing_pieces.first.moves
opposing_pieces.first
opposing_pieces.any?{|piece| piece.moves.include?(king_pos)}
c
   61:       color == :white ? piece.color == :black : piece.color == :white
    opposing_pieces = pieces.select do |piece|
find_king(color)
king_pos
c
exit
board_dup
board_dup[3]
board_dup(3,3)
board_dup([3,3])
