c
opposing_pieces[5].moves
opposing_pieces[2].moves
opposing_pieces
c
exit
c
opposing_piece_at_pos?(newpos)
all_moves
newpos
c
newpos
all_moves
c
opposing_piece_at_pos?(newpos)
self.board.valid_pos?(newpos)
newpos
dir
c
opposing_pieces[3].moves
opposing_pieces[2].moves
opposing_pieces[1].moves
opposing_pieces[0].moves
king_pos
opposing_pieces[5].moves
opposing_pieces[0].moves
opposing_pieces.map{|piece| piece.class}
color
c
self[start_pos].moves
end_pos
start_pos
c
self[start_pos].moves
c
pos
c
pos
c
pos
c
pos
c
pos
c
self.color == :white ? self.board[pos].color == :black : self.board[pos].color == :white
self.board[pos]
self.class
self.color
pos
exit
forward_steps
dir
c
self.pos
c
self.pos
forward_steps
c
dir
forward_steps
c
exit
c
own_pieces.map{|piece| piece.valid_moves}
c
exit
c
in_check?(:white)
own_pieces.first.valid_moves
own_pieces.map{|piece| piece.color}
own_pieces.map{|piece| piece.class}
c
own_pieces
color
c
opposing_pieces
c
piece
c
self.grid
piece
opposing_pieces
piece
piece.moves
opposing_pieces.any?{|piece| piece.moves.include?(king_pos)}
opposing_pieces
king_pos
c
n
finish
c
[i,j]
i
j
i
piece.color
piece.class
piece
c
duped_board.grid
duped_board
c
moves
c
move_dirs
self.pos
c
pos
val
c
pos
val
c
unblocked_moves
c
unblocked_moves
c
self[start_pos].pos
self[end_pos].pos
self[end_pos]
c
self.class
val
@pos
c
@pos
val
c
unblocked_moves
c
self.pos
c
unblocked_moves
c
start_pos
end_pos
self[end_pos]
self[end_pos].to_s
start_pos
self[start_pos].pos
self[end_pos].pos
end_pos
c
exit
self.pos
unblocked_moves
c
end_pos
self[end_pos].pos
self[end_pos]
c
self.pos
c
self.pos
dy
dx
unblocked_moves
c
self.pos
unblocked_moves
c
exit
self.pos
unblocked_moves
self.board.grid
self.board
self.board([0,0]).empty?
self.board([0,0])
self.board[0,0]
self.board.grid
self.board([0,1])
self.board
self.board([0,0])
self.board([0,0]).to_s
self.board
self.board.valid_pos?([6,0])
unblocked_moves
c
unblocked_moves
c
unblocked_moves
c
unblocked_moves
c
startpos
all_moves
c
all_moves
c
all_moves
c
exit
all_moves
exit
self.board.valid_pos?([0,0])
all_moves
c
self[start_pos].moves.include?(end_pos)
start_pos
c
all_moves
c
all_moves
c
all_moves
c
all_moves
c
all_moves
c
pos
c
all_moves
c
all_moves
c
all_moves
c
all_moves
c
pos
c
all_moves
c
pos
c
pos
c
all_moves
c
pos
c
pos
c
pos
c
pos
c
pos
c
pos
c
unblocked_moves
c
pos
exit
all_moves
unblocked_moves
c
unblocked_moves
c
all_moves
c
all_moves
c
